name: Manga Automation

on:
  push:
    branches:
      - main
    paths:
      - '**/*.jpg'
      - '**/*.jpeg'
      - '**/*.png'
      - '**/*.webp'
  
  schedule:
    - cron: '0 0 * * *'
  
  workflow_dispatch:

permissions:
  contents: write

jobs:
  manga-automation:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'
      
      - name: Update manga.json and chapters.json (preserve metadata)
        run: |
          python3 << 'PYTHON_SCRIPT'
          import os
          import json
          import subprocess
          import re
          from datetime import datetime

          print("ğŸš€ Starting manga automation (preserving metadata)...")
          print("")

          def get_git_commit_date(folder_path):
              """Get FIRST Git commit date when folder was created"""
              try:
                  # Get first commit (oldest) for this folder
                  result = subprocess.run(
                      ['git', 'log', '--reverse', '--format=%aI', '--', folder_path],
                      capture_output=True,
                      text=True,
                      check=True
                  )
                  commits = result.stdout.strip().split('\n')
                  first_commit = commits[0] if commits and commits[0] else None
                  
                  if first_commit:
                      return first_commit
                  else:
                      # Fallback: use current time
                      return datetime.utcnow().isoformat() + 'Z'
                      
              except Exception as e:
                  return datetime.utcnow().isoformat() + 'Z'

          def is_chapter_folder(folder_name):
              """Check if folder is a chapter"""
              pattern = r'^\d+(\.\d+)?$'
              return re.match(pattern, folder_name) is not None

          def parse_chapter_number(folder_name):
              """Parse chapter number"""
              try:
                  return float(folder_name)
              except:
                  return 0.0

          # ============================================
          # STEP 1: Load existing manga.json (PRESERVE ALL METADATA!)
          # ============================================
          existing_manga_data = {}
          if os.path.exists('manga.json'):
              try:
                  with open('manga.json', 'r', encoding='utf-8') as f:
                      existing_manga_data = json.load(f)
                  print("âœ… Loaded existing manga.json (will preserve ALL metadata)")
              except:
                  print("âš ï¸  Could not load existing manga.json")
          
          # ============================================
          # STEP 2: Scan chapters from disk
          # ============================================
          print("")
          print("ğŸ“‚ Scanning for chapters on disk...")
          chapters_dict = {}
          chapter_list = []
          scanned_keys = set()
          
          for item in os.listdir('.'):
              if os.path.isdir(item) and is_chapter_folder(item):
                  chapter_num = parse_chapter_number(item)
                  
                  image_files = [f for f in os.listdir(item) 
                                if f.lower().endswith(('.jpg', '.jpeg', '.png', '.webp'))]
                  
                  # Title
                  if chapter_num.is_integer():
                      title = f"Chapter {int(chapter_num)}"
                      chapter_key = str(int(chapter_num))
                  else:
                      title = f"Chapter {chapter_num}"
                      chapter_key = str(chapter_num)
                  
                  scanned_keys.add(chapter_key)
                  
                  # Check if chapter already exists in old data
                  old_chapter = existing_manga_data.get('chapters', {}).get(chapter_key, {})
                  
                  # IMPORTANT: For NEW chapters only, get Git date
                  # For EXISTING chapters, preserve old date
                  if old_chapter:
                      # Chapter exists â†’ PRESERVE old date
                      upload_date = old_chapter.get('uploadDate', get_git_commit_date(item))
                      is_new = False
                  else:
                      # NEW chapter â†’ Get accurate Git date
                      upload_date = get_git_commit_date(item)
                      is_new = True
                  
                  chapter_data = {
                      "title": old_chapter.get('title', title),  # Preserve custom title if exists
                      "chapter": chapter_num,
                      "folder": item,  # IMPORTANT: Add folder field!
                      "uploadDate": upload_date,
                      "totalPages": len(image_files),
                      "pages": len(image_files),  # Alias for compatibility
                      "locked": old_chapter.get('locked', False),  # Preserve locked status!
                      "views": old_chapter.get('views', 0)  # Preserve views!
                  }
                  
                  chapters_dict[chapter_key] = chapter_data
                  chapter_list.append(chapter_data)
                  
                  status = "ğŸ†• NEW" if is_new else "âœ…"
                  print(f"  {status} {item}: {title} ({len(image_files)} pages, views: {chapter_data['views']}, date: {upload_date[:10]})")
          
          print("")
          print(f"âœ… Found {len(chapter_list)} chapters on disk")
          
          # ============================================
          # STEP 3: Preserve locked chapters from old manga.json
          # ============================================
          print("")
          print("ğŸ”’ Checking for locked chapters to preserve...")
          locked_count = 0
          
          old_chapters = existing_manga_data.get('chapters', {})
          for chapter_key, old_chapter in old_chapters.items():
              # If chapter is locked AND not scanned from disk, preserve it
              if old_chapter.get('locked', False) and chapter_key not in scanned_keys:
                  chapters_dict[chapter_key] = dict(old_chapter)  # Preserve ALL fields
                  chapter_list.append(dict(old_chapter))
                  locked_count += 1
                  print(f"  ğŸ”’ Preserved locked chapter: {old_chapter.get('title', chapter_key)} (not on disk)")
          
          if locked_count > 0:
              print(f"âœ… Preserved {locked_count} locked chapters")
          else:
              print("â„¹ï¸  No locked chapters to preserve")
          
          print("")
          print(f"âœ… Total chapters: {len(chapter_list)} ({len(scanned_keys)} on disk + {locked_count} locked)")
          
          # ============================================
          # STEP 3.5: Update null uploadDate for locked chapters
          # ============================================
          # Find the latest uploadDate from chapters on disk
          latest_date = None
          for ch in chapter_list:
              ch_date = ch.get('uploadDate')
              if ch_date and ch_date != 'null':
                  if latest_date is None or ch_date > latest_date:
                      latest_date = ch_date
          
          print(f"ğŸ” Debug: Latest date found: {latest_date}")
          
          # Update locked chapters with null uploadDate to use latest date
          if latest_date:
              print("")
              print("ğŸ“… Updating locked chapters with null uploadDate...")
              updated_count = 0
              for chapter_key, chapter_data in chapters_dict.items():
                  current_date = chapter_data.get('uploadDate')
                  is_locked = chapter_data.get('locked', False)
                  print(f"  ğŸ” Debug: {chapter_key} - locked={is_locked}, uploadDate={current_date}, type={type(current_date)}")
                  if is_locked and current_date is None:
                      chapter_data['uploadDate'] = latest_date
                      updated_count += 1
                      print(f"  âœ… {chapter_data['title']}: uploadDate updated to {latest_date}")
              
              # Also update in chapter_list
              for chapter_data in chapter_list:
                  if chapter_data.get('locked', False) and chapter_data.get('uploadDate') is None:
                      chapter_data['uploadDate'] = latest_date
              
              print(f"âœ… Updated {updated_count} locked chapters")
          else:
              print("âš ï¸  No valid date found to update locked chapters")
          
          # ============================================
          # STEP 4: Sort chapters by UPLOAD DATE (DESC) for chapters.json
          # ============================================
          # Sort by uploadDate (DESC), then by chapter number (ASC)
          # When dates are the same, chapters appear in correct numeric order
          def sort_key(chapter):
              upload_date = chapter.get('uploadDate')
              # Convert None to empty string for sorting
              if upload_date is None:
                  upload_date = ''
              chapter_num = chapter.get('chapter', 0)
              # For DESC date but ASC chapter: negate date comparison
              # Since we can't negate strings, we'll do two-pass sort
              return (upload_date, chapter_num)
          
          # Sort by chapter number first (ASC)
          chapter_list.sort(key=lambda x: x.get('chapter', 0))
          # Then stable sort by date (DESC) - this preserves chapter order for same dates
          chapter_list.sort(key=lambda x: x.get('uploadDate') or '', reverse=True)
          
          # Get last chapter update
          last_chapter_update = None
          if chapter_list:
              last_chapter_update = chapter_list[0].get('uploadDate')
              if last_chapter_update:
                  print(f"ğŸ“… Last chapter update: {last_chapter_update}")
          
          # ============================================
          # STEP 5: Build manga.json (PRESERVE ALL METADATA!)
          # ============================================
          
          # Get existing manga metadata
          existing_manga_info = existing_manga_data.get('manga', {})
          
          # START with ALL existing fields (COMPLETE preservation!)
          manga_info = dict(existing_manga_info)  # Copy ALL existing fields
          
          # Only update/add these minimal required fields if they don't exist
          if 'title' not in manga_info:
              manga_info['title'] = os.path.basename(os.getcwd())
          if 'cover' not in manga_info:
              manga_info['cover'] = 'cover.jpg'
          if 'views' not in manga_info:
              manga_info['views'] = 0
          
          # Build final manga.json with NUMERIC SORTED keys
          sorted_chapter_keys = sorted(chapters_dict.keys(), key=lambda k: parse_chapter_number(k))
          sorted_chapters_dict = {k: chapters_dict[k] for k in sorted_chapter_keys}
          
          manga_data = {
              "manga": manga_info,
              "chapters": sorted_chapters_dict,
              "lastChapterUpdate": last_chapter_update,
              "lastUpdated": datetime.utcnow().isoformat() + 'Z'
          }
          
          # ============================================
          # STEP 6: Build chapters.json (for website - sorted by upload date DESC)
          # ============================================
          chapters_data = {
              "chapters": chapter_list  # Already sorted by uploadDate DESC
          }
          
          # ============================================
          # STEP 7: Write files
          # ============================================
          print("")
          print("ğŸ’¾ Writing files...")
          
          with open('manga.json', 'w', encoding='utf-8') as f:
              json.dump(manga_data, f, indent=2, ensure_ascii=False)
          print("  âœ… manga.json updated (ALL metadata preserved!)")
          
          with open('chapters.json', 'w', encoding='utf-8') as f:
              json.dump(chapters_data, f, indent=2, ensure_ascii=False)
          print("  âœ… chapters.json updated (sorted by upload date)")
          
          print("")
          print("=" * 60)
          print("ğŸ“Š SUMMARY")
          print("=" * 60)
          print(f"Manga: {manga_info.get('title', 'N/A')}")
          print(f"Total Chapters: {len(chapter_list)}")
          print(f"  - On disk: {len(scanned_keys)}")
          print(f"  - Locked (preserved): {locked_count}")
          if chapter_list:
              first_date = chapter_list[0].get('uploadDate', 'N/A')
              last_date = chapter_list[-1].get('uploadDate', 'N/A')
              print(f"Latest: {chapter_list[0]['title']} (uploaded: {first_date if first_date else 'N/A'})")
              print(f"Oldest: {chapter_list[-1]['title']} (uploaded: {last_date if last_date else 'N/A'})")
          print(f"Last Update: {last_chapter_update if last_chapter_update else 'N/A'}")
          
          # Show preserved metadata
          preserved_fields = []
          if 'alternativeTitle' in manga_info:
              preserved_fields.append('alternativeTitle')
          if 'description' in manga_info:
              preserved_fields.append('description')
          if 'author' in manga_info:
              preserved_fields.append('author')
          if 'genre' in manga_info:
              preserved_fields.append('genre')
          if 'links' in manga_info:
              preserved_fields.append('links')
          
          if preserved_fields:
              print(f"Metadata: âœ… Preserved ({', '.join(preserved_fields)})")
          else:
              print(f"Metadata: âš ï¸  New manga (no existing metadata)")
          
          print("=" * 60)
          
          PYTHON_SCRIPT
      
      - name: Commit and push changes
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          
          git pull origin main --rebase || true
          git add manga.json chapters.json 2>/dev/null || true
          
          if git diff --staged --quiet; then
            echo "âœ… No changes to commit"
          else
            if [ "${{ github.event_name }}" = "push" ]; then
              COMMIT_MSG="ğŸ“š Auto-update chapters (metadata preserved) [skip ci]"
            elif [ "${{ github.event_name }}" = "schedule" ]; then
              COMMIT_MSG="ğŸ“Š Daily refresh (metadata preserved) [skip ci]"
            else
              COMMIT_MSG="ğŸ”„ Manual update [skip ci]"
            fi
            
            git commit -m "$COMMIT_MSG"
            
            max_retries=3
            count=0
            until git push origin main; do
              count=$((count+1))
              if [ $count -eq $max_retries ]; then
                echo "âŒ Failed to push after $max_retries attempts"
                exit 1
              fi
              echo "âš ï¸  Retrying push... (attempt $count/$max_retries)"
              sleep 5
              git pull origin main --rebase
            done
            
            echo "âœ… Successfully pushed changes"
          fi
      
      - name: Show Summary
        if: always()
        run: |
          echo ""
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘       AUTOMATION SUMMARY               â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "Trigger: ${{ github.event_name }}"
          echo "Time: $(date)"
          echo ""
          
          if [ -f manga.json ]; then
            echo "ğŸ“Š Manga Stats:"
            MANGA_TITLE=$(jq -r '.manga.title' manga.json)
            TOTAL_CHAPTERS=$(jq '.chapters | length' manga.json)
            LAST_UPDATE=$(jq -r '.lastChapterUpdate // "N/A"' manga.json)
            HAS_DESCRIPTION=$(jq -r '.manga.description // "N/A"' manga.json)
            HAS_AUTHOR=$(jq -r '.manga.author // "N/A"' manga.json)
            
            echo "  Title: $MANGA_TITLE"
            echo "  Chapters: $TOTAL_CHAPTERS"
            echo "  Last Update: $LAST_UPDATE"
            
            if [ "$HAS_DESCRIPTION" != "N/A" ]; then
              echo "  âœ… Description: Preserved"
            fi
            
            if [ "$HAS_AUTHOR" != "N/A" ]; then
              echo "  âœ… Author: $HAS_AUTHOR"
            fi
            
            echo ""
            echo "ğŸ“– Latest Chapters (from chapters.json):"
            jq -r '.chapters[:3] | .[] | "  - \(.title) (\(.uploadDate))"' chapters.json
          fi
          
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
